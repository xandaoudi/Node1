*** Node.js: Desenvolvendo com JavaScript no backend ***

O que é o Node.js?
  Node é uma plataforma que possibilita o desenvolvimento de aplicações no backend utilizando a linguagem JavaScript, que 
  inicialmente foi criada para rodar somente no navegador.
  O objetivo é exercutar uma aplicação em JavaScript no backend, fazendo com que ela receba requisições do navegador e devolva
respostas, tudo por meio do protocolo HTTP.

Node funciona com qualquer arquivo JS.

Um módulo Node é como uma biblioteca, ou seja, um conjunto de funcionalidades que ajudar a resolver determinadas tarefas. Sendo assim,
no mundo Node, um arquivo com a extensão .js já é um módulo.
O módulo http já é disponibilizado pelo Node.js. E para importar-lo devemos utilizar a seguinte sintaxe:
const http = require('http')

Depois de importar o módulo do http, devemos executar o método createServer(), que retornar um objeto do tipo Server. 
  Ex:
    const http = require('http')
    const servidor = http.createServer()
Após ter criado o servidor precisamos definir em qual porta ele irá rodar:

    const http = require('http')
    const servidor = http.createServer()
    servidor.listen(3000)

Ainda precisamos definir que esse servidor deverá fazer ao receber uma requisição. O método createServer() pode receber como parâmetro 
opcional uma função que será executada toda vez que o servidor receber uma requisição do cliente (requestListener). Essa função recebe 
dois parâmetros, request e response.
Portanto criaremos uma função anônima recebendo esse 2 parâmetros. De posse desses objetos, definiremos o que o Node precisará fazer na requisição
e na resposta. 

  const http = require('http');

  const servidor  = http.createServer(function (req, resp) {
      resp.end(`
          <html>
             <head>
                 <meta charset="utf-8">
              </head>
              <body>
                  <h1> Casa do Código </h1>
             </body> 
          </html>
      `);
  });
  servidor.listen(3000);

Lembre-se que a função que passamos para o método createServer() só será executada quando servidor receber uma requisição do cliente.
No mundo Java, e também em outras linguagens de programação, funções que só executada dada ocorrência de um evento são chamadas de "funções callback",
que serão muito utilizadas no Node.

Para possibilitar que a aplicação devolva respostas diferentes para cada requisição feita pelo usuário no cliente, primeiramente, precisamos
verificar qual é o pedido que está sendo feito pelo usuário. Para isso, faremos uma verificação a partir da requisição, buscando a URL solicitada.
Vamos declarar, dentro da função callback, uma variável html que inicialmente não receberá valor algum.
Então, se essa URL for igual à raiz da nossa aplicação( if(req.url == '/')), devolveremos um trecho de HTML.

  const http = require('http')
  const servidor = http.createServer(function (req, resp) {
    let html = ''
    if (req.url == '/') {
      html = 
      <html>
            <head>
                <meta charset="utf-8">
            </head>
            <body>
                <h1> Casa do Código </h1>
            </body> 
        </html>
    `;
    }
    resp.end(html)
  })
  servidor.listen(3000)

Também queremos ser capazes de atender outros caminhos na nossa aplicação. Em uma aplicação WEB, esses caminhos são chamados de rotas. Podemos criar uma rota
acrescentando um else if (req.url == '/livos'), ou seja, buscando a propriedade /livros na URL da requisição. Em seguida atribuímos um novo valor
a variável html:
  
  const servidor  = http.createServer(function (req, resp) {

    let html = '';
    if (req.url == '/') {
        html = `
        <html>
            <head>
                <meta charset="utf-8">
            </head>
            <body>
                <h1> Casa do Código </h1>
            </body> 
        </html>
    `;
    } else if (req.url == '/livros')
        html = `
        <html>
            <head>
                <meta charset="utf-8">
            </head>
            <body>
                <h1> Listagem de livros </h1>
            </body> 
        </html>
    `;

    resp.end(html);

Dessa forma se quiséssemos adicionar outras rotas precisaríamos adicionar outros else if() sucessivamente. O que não é uma boa idéia, pois
podemos ter um problema chamado complexidade ciclomática: quanto mais caminhos o programa tiver, mais complexo e de difícil manutenção o seu código será.
A aplicações web também possuem requisições do tipo: GET, PUT, POST, DELETE, que não estão sendo tratadas no exemplo acima. (somente requisição do tipo GET)
Para transfomar o projeto no tipo Node devemos digitar o seguinte comando no terminal "npm init"
Após o comando npm init finalizar no projeto irá aparecer um arquivo "package.json".
Esse arquivo é muito importante, pois define o nosso projeto como sendo do tipo Node, e assim poderemos instalar outros módulos.
No projeto será instalado o módulo do express utilizando o comando no terminal:
  npm install express@4.16.3 --save-exact
  Obs: --save significa que o módulo deve ser salvo no projeto
      @1.1.1 significa a versão que deseja instalar
      -exact siginifica que deve instalar a versão exata especificada.

Por fim, criaremos uma pasta chamada "src" (de source) na raiz do projeto, na qual armazenará todo e qualquer código relativo à aplicação.
Dentro da pasta src será criada duas pasta:
  ."app": que armazenará os códigos relativos à lógica
  ."config": que armazenará os códigos relativos de configuração.

Após a instalação do express, é preciso colocá-lo para funcionar no projeto. Portanto, ínicio do arquivo server.js, criaremos uma constante
express que receberá a chamada para o módulo de mesmo nome (require('express')). O retorno desse método será uma função.
Chamaremos essa função com express(), obtendo um objeto do tipo express que poderemos utlizar paa configurar a nossa aplicação.

    const app = express()
De posse da constante app, estaremos habiltados a criar o nosso servidor utilizando o express. Para isso, executaremos o método listes(), que 
recebe como primeiro parâmetro o número da porta na qual o servidor rodará (3000). Também poderíamos indicar um hostname, o que não queremos no momento,
e receber uma função de callback.
Quando criamos o servidor usando o protocolo HTTP, definimos um callback que seria executado sempre que recebêssemos uma requisição web. No caso do
express, esse callback só será executado quando o nosso servidor for iniciado
Nesse momento, escreveremos a mensagem "Servidor Rodando na porta 3000" na tela.
    app.listen(3000, (){
        console.log('Servidor rodando na porta 3000')
    })

Para definir a resposta de uma requisição na raiz do projeto pelo método GET, no arquivo server.js pegaremos a constante app e executaremos o método get()
Esse método receberá dois parâmetros: uma string representando o caminho que queremos atender, e uma função do tipo callback que será executada sempre que o 
cliente acessar esse caminho.
Essa função receberá a requisição e a resposta (req, resp), e seu corpo indicará a resposta enviada ao usuário. Da mesma forma como era feito trabalhando com módulo
HTTP, passaremos o objeto representando a resposta (resp) e executaremos o método send(), recebendo como parâmetro uma string que representando o HTML.

    app.get('/', function(req, resp) {
        resp.send(
            `
                <html>
                    <head>
                        <meta charset="utf-8">
                    </head>
                    <body>
                        <h1> Casa do Código </h1>
                    </body> 
                </html>
            `
        );
    });

Para criarmos uma nova rota na nossa aplicação, basta repetirmos o processo.

    app.get('/livros', function(req, resp) {
        resp.send(
            `
                <html>
                    <head>
                        <meta charset="utf-8">
                    </head>
                    <body>
                        <h1> Listagem de livros </h1>
                    </body> 
                </html>
            `
        );
    });

Nessa etapa tentaremos melhorar o design do código da nossa aplicação. Vamos relembrar o que foi feito até agora

        const express = require('express');

        const app = express()

        app.listen(3000, function() {
            console.log('Servidor rodando na porta 3000');

        });

        app.get('/', function(req, resp) {
            resp.send(
                `
                    <html>
                        <head>
                            <meta charset="utf-8">
                        </head>
                        <body>
                            <h1> Casa do Código </h1>
                        </body> 
                    </html>
                `
            );
        });

        app.get('/livros', function(req, resp) {
            resp.send(
                `
                    <html>
                        <head>
                            <meta charset="utf-8">
                        </head>
                        <body>
                            <h1> Listagem de livros </h1>
                        </body> 
                    </html>
                `
            );
        });

Nós trouxemos o módulo express para o nosso código com o require('express), e em seguida chamamos a função express(). Com o método listen(),
criamos um servidor, definindo duas rotas com o método GET para a aplicação.
Repare que o arquivo server.js está fazendo três coisas diferentes:
    . a importação do express
    . a criação do servidor
    . a definição das rotas

Seguindo um princípio da programação, nossos códigos precisam ter responsabilidades únicas. Portanto, nosso objetivo é separar essas responsabilidades.
Primeiramente, criaremos um módulo customizado que importe o express() e executaremos a função express(), atribuindo seu retorno à uma constante app. Para isso,
dentro da pasta config(que está dentro da pasta 'src'), criaremos o arquivo custom-express.js. E passaremos para esse novo arquivo o código a seguir:

    const express = require('express');

    const app = express();
No arquivo server.js, precisaremos passar o caminho do módulo que foi criado. Isso é feito com o ./, indicando a raiz do projeto, seguido do resto do caminho:
    const app = require('./src/config/custom-express');

Se executarmos nosso código dessa maneira, receberemos um erro: o Node não conseguirá identificar o método liste() no objeto app. Isso acontece pois em nenhum
momento exportamos esse objeto do express no módulo customizado. Para corrigir esse problema, basta escrever as exportações desse módulo no arquivo custom-express.js
    module.exports = app

Dando continuidade às refatorações do nosso código, o objetivo é encapsular as rotas da aplicação em um arquivo específico.
Dentro da pasta "app", criaremos uma nova pasta "rotas", onde ficarão todos os arquivos referentes a rotas das aplicação. Nessa pasta, criaremos
o arquivo rotas.js, que abrigará o código relativo aos caminhos que escreveremos anteriormente.
  
        app.get('/', function(req, resp) {
        resp.send(
            `
                <html>
                    <head>
                        <meta charset="utf-8">
                    </head>
                    <body>
                        <h1> Casa do Código </h1>
                    </body> 
                </html>
            `
        );
    });

    app.get('/livros', function(req, resp) {
        resp.send(
            `
                <html>
                    <head>
                        <meta charset="utf-8">
                    </head>
                    <body>
                        <h1> Listagem de livros </h1>
                    </body> 
                </html>
            `
        );
    });

Ainda precisamos declarar a importação desse módulo de rotas. Porém, não faremos isso no arquivo server.js, pois queremos manter nele somente a criação
do servidor. Ou seja, essa importação será feita no custom-express.js, onde é a customização do módulo. Após a criação da constante app, vamos delcarar pedindo 
a importação do arquivo de rotas:
    require('../app/rotas/rotas)

Se tentarmos executar o server.js nesse ponto, receberemos um erro, já que o módulo rotas.js possui um objeto app que em nenhum momento foi declarado.
No custom-express.js, criaremos uma constante rota que será retornada pela importação desse módulo. A partir dela, passaremos o objeto app como parâmetro.
    const rotas = require('../app/rotas/rotas.js');
    rotas(app);

No arquivo rotas.js, precisaremos exportar uma função(que, no mundo JavaScript, é a instrução capaz de receber um parâmetro) capaz de receber o objeto app.
É possível fazer isso com module.exports.

Criaremos essa função utilizando a sintaxe do ECMASCRIPT 6, que introduziu as famosas arrow functions:

    module.exports = (app) => {

    }
Para nosso código ficar mais elegante, passaremos a construção das rotas para dentro da declaração do module.exports:

    module.exports = (app) => {
        app.get('/', function(req, resp) {
            resp.send(
                `
                <html>
                    <head>
                        <meta charset="utf-8">
                    </head>
                    <body>
                        <h1> Casa do Código </h1>
                    </body> 
                </html>
            `
            )
        })
        ...
    }

Agora podemos salvar todas as alterações na nossa aplicação e executar o server.js. A aplicação funcionará corretamante, mostrando os textos que definimos
anteriormente em suas respectivas URL.

Para toda e qualquer alteração feita no nosso códigom precisamos salvar o arquivo, parar o servidor, executá-lo novamente com o node server.js e então
testá-lo no navegador. Seria mais interessante se tivéssemos um mecanismo que automaticamente atualizasse a instância do servidor a cada salvamento do projeto,
permitindo que testássemos as alterções diretamente no navegador. No mundo Node, uma dos mais conhecidos módulos que faz isso é o Nodemon.
Vamos instá-lo com o comando npm install nodemon --save-dev, para o Nodemon ser instalado no projeto. Após isso devemos instalar ele globalmente na nossa máquina
através do comando npm i -g nodemon.
No arquivo package.json, temos uma seção scripts, que indica como o Node pode executar nosso projeto:

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
Repare que, se executarmos o comando npm test, será devolvido um erro informando que não é um teste especificado para nossa aplicação. 
Já se usarmos npm start, o comando node server.js será executado. Vamos alterar esse campo para que nodemon server.js seja executado.
Feito isso, no terminal, poderemos utilizar os comandos especificados, desde que estejamos acessando a pasta do projeto.
Se executarmos npm start, o script definido (nesse caso, nodemon server.js) rodará.

** Listagem estática de livros **

Nessa etapa, começaremos a criar uma listagem de livros. Para isso, usaremos a biblioteca marko.js, bastante conhecida no mundo Node, que serve
para gerar templates HTML. Inclusive, ele funciona muito bem com o express.
No terminal, executaremos o seguinte comando:
    npm i marko@4.13.4-1 --save-exact
Dessa forma, instalaremos uma versão específica do Marko, que será listado, no package.json, como uma das dependências da nossa aplicação.
Para habilitarmos essa biblioteca na nossa aplicação, precisaremos adicionar duas linhas de código no arquivo custom-express.js, onde configuramos
o express no nosso projeto:
    require('marko/node-require').install()
    require('marko/express')

Na pasta "app", criaremos uma nova pasta chamada "views", na qual armazenaremos todos os arquivos de visualização do sistema. Nela, criaremos outra pasta,
chamada "livros", onde ficarão todas as páginas referentes ao domínio de livros(listagem, adição, remoção e assim por diante).
Dentro dela, teremos uma subpasta, chamada "lista", na qual criaremos um arquivo lista.marko. Todos os arquivos com a extensão .marko(que funcionam com o Marko)
serão compostos por puro HTML. No rotas.js, removeremos o código HTML que criamos para a rota "/livros", e colaremos nesse novo arquivo, adicionando
uma simples tabela com duas colunas e um único elemento:
    <html>
        <head>
            <meta charset="utf-8">
        </head>
        <body>
            <h1> Listagem de livros </h1>

            <table>
                <tr>
                    <td>ID</td>
                    <td>Título</td>
                </tr>
                    <tr>
                    <td>1</td>
                    <td>Fundamentos do Node</td>
                </tr>
            </table> 
        </body> 
    </html>
No rota.js, estávamos criando um HTML fixo dentro do método resp.send(). Agora, queremos acessar o conteúdo armazenado em lista.marko. Para
isso, executaremos o método resp.marko(), que foi habilitado com a inclusão do Marko no projeto. Com ele poderemos exibir arquivos .marko para o cliente
na resposta, sendo necessário apenas importar o arquivo com a essa extensão, o que também é feito com o método require().

    app.get('/livros', function(req, resp) {
        resp.marko(
            require('../views/livros/lista/lista.marko')

        );
    });

** Templates dinâmicos **

Anteriormente, conseguimos utilizar o resp para chamar o método marko(), que recebe a página a ser mostrada no navegador. Além desse parâmetro, 
o método também pode receber um objeto JavaScript contendo informações que queremos enviar para a tela. Para isso só precisamos definir as chaves
e os valores do objeto.
Por exemplo, se queremos fazer uma listagem de livros, podemos definir uma chave chamada livros, passando, como valor, um objeto ou um array JavaScript.
Nesse caso, preparamos um array com dois livros, cada um com seu id e titulo:

    app.get('/livros', function(req, resp) {
        resp.marko(
            require('../views/livros/lista/lista.marko'),
            {
                livros: [
                    { 
                        id: 1,
                        titulo: 'Fundamentos do Node'
                    },
                    { 
                        id: 2,
                        titulo: 'Node Avançado'
                    }
                ]
            }

        );
    });

Agora precisamos recuperar essa informação no nosso template, e a linguagem Marko possui uma sintaxe que nos auxiliará nesse processo.
Na tag <tr> de "lista.marko", na qual havíamos definido o livro estático, criaremos um for() recebendo data, uma variável disponibilizada pelo Marko
cujo valor representará o objeto JavaScript que passamos no segundo parâmetro da função marko(). Como esse objeto tem uma propriedades livros, 
podemos acessá-la com o auxílio de uma variável auxiliar for (data.livros).
Agora queremos imprimir o id e o titulo da variável livro. Para isso, usaremos uma marko expression, que é uma forma de referenciar uma variável
em nossa página. Ela é utilizada com ${}, passando a referência dentro dessa expressão:

    <html>
        <head>
            <meta charset="utf-8">
        </head>
        <body>
            <h1> Listagem de livros </h1>

            <table>
                <tr>
                    <td>ID</td>
                    <td>Título</td>
                </tr>
                    <tr for (livro in data.livros)>
                    <td>${livro.id}</td>
                    <td>${livro.titulo}</td>
                </tr>
            </table> 
        </body> 
    </html>

Reflexões:

Como já falamos anteriormente, o método require()(que utilizamos para importar a página de listagem para o método marko()) na realidade importa 
módulos Node. Porém, nesse caso, estamos importando um arquivo .marko. Estranho não?
Repare quem quando executamos nossa aplicação, o Marko tansforma lista.marko em um arquivo lista.marko.js, que é um módulo do Node, possibilitando assim 
essa importação.

** Acessando o Banco de Dados **

Vamos dar continuidade ao nosso projeto de modo que finalmente consigamos tornar a nossa listagem de livros dinâmica, ou seja, fazendo 
acesso a um banco de dados.
Antes de tudo, no terminal, executaremos o comando npm install sqlite3@4.0.2 --save-exact para instalar o banco de dados que utilizaremos.
Com o SQlite habilitado, precisaremos colocar o arquivo database.js dentro da pasta "config" do projeto.
Esse arquivo importará o SQlite e criará uma instância do nosso banco de dados:
    const sqlite3 = require('sqlite3').verbose()
    const bd = new sqlite3.Database('data.db')

Com essa sintaxe, o Node criará um arquivo data.db dentro da pasta do nosso projeto, representando o banco de dados que iremos utilizar.
Ao final, ele disponibilizará a instância do banco de dados por meio do módulo que o nosso arquivo database.js representa, de mode que 
possamos manipular esse banco em outro arquivos.

No arquivo rotas.js, vamos criar uma constante db recebendo require(), passando o caminho do módulo onde o banco de dados foi configurado:
    const db = require('../../config/database)

Dessa forma, teremos uma instância desse banco de dados. Em seguidam na rota /livros, escreveremos db.all(), que é um método do SQlite executado
quando queremos fazer algum tipo de listagem. Esse método receberá dois parâmetros: o primeiro, uma string representando a consulta que queremos fazer,
e o segundo, uma função callback que será executada quando a nossa consulta tiver terminado.
Essa função callback receberá dois parâmetros: erro, se ocorrer algum erro nessa consultam e resultados. Como queremos selecionar todos os dados da tabela
livros, a string que passaremos será SELECT * FROM livros:

    app.get('/livros', function(req, resp) {
        db.all('SELECT * FROM livros', function(erro, resultados) {

        });

Se a nossa consulta der certo, os livros retornados serão armazenados no parâmetro resultados. Então, continuaremos chamando o template de listagem e
passando os livros para a nossa página. Porém dessa vez, os itens dessa lista não serão estáticos, mas sim o resultados vindos do banco de dados.
Desse modo, passaremos o código do método marko() para dentro da função callback, substituindo os itens estáticos da lista pelos resultados:

    app.get('/livros', function(req, resp) {
        db.all('SELECT * FROM livros', function(erro, resultados) {

            resp.marko(
                require('../views/livros/lista/lista.marko'),
                {
                    livros: resultados
                }

            );

        });


    });

** O padrão DAO **

Nessa nova etapa, aprenderemos um pouco sobre o padrão DAO, que é capaz de melhorar o código.
Antes de tudo, vamos analisar o código da rota /livros:

    app.get('/livros', function(req, resp) {
        db.all('SELECT * FROM livros', function(erro, resultados) {

            resp.marko(
                require('../views/livros/lista/lista.marko'),
                {
                    livros: resultados
                }

            );

        });


    });

Nele, com a instância  do banco de dados(db), estamos executando o método all(), utilizado pelo SQlite para fazer uma consulta no banco de dados.
Para isso, passamos a string dessa consulta e uma função callback instruindo que o JavaScript precisa fazer quando essa funcionalidade assíncrona 
de acesso ao banco tiver terminado.
Porém esse código não têm semântica. Uma pessoa que não entende de SQL, por exemplo, não saberia imediatamente que estamos listando os livros.
Gostaríamos de ter uma função listaLivros() que fosse responsável por essa ação. Nela, só precisaríamos passar o callback da nossa função all(), instruindo o 
que deve ser feito para quando terminada a execução desse método de listagem.

    app.get('/livros', function(req, resp) {

        listaLivros(function(erro, resultados) {

            resp.marko(
                require('../views/livros/lista/lista.marko'),
                {
                    livros: resultados
                }

            );

        });
    });

Mas de onde viria essa função listaLivros(), que não aparece em nenhum momento do código?
Dentro da pasta "app", criaremos uma nova pasta, chamada "infra". Dentro dela, criaremos o arquivo livro-dao.js, no qual definiremos uma classe
do ECMASCRIPT6, chamada LivroDao:
    class LivroDao {

    }

Essa classe no fornecerá toda e qualquer funcionalidade relativa aos livros no banco de dados, como listagem, adição, remoção, edição e assim por diante.
Desse modo, faz sentido que toda instância de LivroDao tenha uma referência para o nosso banco de dados.
Portanto, definiremos um constructor recebendo a instância db. Em seguida, definiremos que o atributo _db da nossa própria classe deverá receber o parâmetro db
passado para o nosso constructor.

    class LivroDao {
        constructor(db) {
            this._db = db;
        }
    }

De posse da referência para o banco de dados, podemos criar o método listaLivros(), recebendo um parâmetro que chamaremos de callback. No corpo do método,
pegaremos o atributo _db e chamaremos o método all(), passando o SQL que queremos executar, ou seja, o SELECT, que já havíamos construído no arquivo rotas.js, e a nosssa
função callback, que recebe o erro e resultados.

No corpo dessa função, chamaremos o callback(), passando os valores de erro e resultados gerados pela nossa consulta.

 class LivroDao {
     constructor(db){
         this._db = db
     }

    listaLivros(callback) {
        this._db.all(
            'SELECT * FROM livros',
            (erro, resultados) => callback(erro, resultados)
        )
    } 
 }

Vamos recapitular o que construímos nesse código? Nós iremos delegar à classe LivroDao o acesso ao banco de dados. Ela teŕa um método listaLivros() que,
quando executado, fará a seleção dos livros no banco. Ao término da seleção, a classe delegará ao callback, passado por listaLivros, o tratamento dos resultados ou do erro.
Ainda precisamos exportar a classe LivroDao, para que possamos utilizá-la em outros módulos da aplicação. O module.exports é capaz de exportar um
tipo definido por uma classe:
    module.exports = LivroDao

De volta ao rotas.js, iremos importar a classe que acabamos de criar:
    const LivroDao = require('../infra/livro-dao')
    Obs: repare que estamos usando LivroDao, com letra maiúscula, pois é uma referência exata à classe que criamos.

Na rota /livros:
  app.get('/livros', function(req, resp) {

    const livroDao = new LivroDao(db);

    livroDao.listaLivros(function(erro, resultados) {

        resp.marko(
            require('../views/livros/lista/lista.marko'),
            {
                livros: resultados
            }

        );

    });

});

Porém, ainda há um detalhe incômodo... se já estamos na classe LivroDao, faz sentido chamarmos um método listaLivros()? A resposta é obviamente, não. Portanto,
vamos refatorar nosso método para somente lista(). Faremos isso em livro-dao.js:

    class LivroDao {

        constructor(db) {
            this._db = db;
        }

        lista(callback) {
            this._db.all(
                'SELECT * FROM livros',
                (erro, resultados) =>
                    callback(erro, resultados)

            )

        }

    }

    module.exports = LivroDao;

E também em rotas.js:

    app.get('/livros', function(req, resp) {

        const livroDao = new LivroDao(db);

        livroDao.lista(function(erro, resultados) {

            resp.marko(
                require('../views/livros/lista/lista.marko'),
                {
                    livros: resultados
                }

            );

        });

    });

Ainda falta respodermos uma pergunta básica... por que chamamos o arquivo e a classe de livro-dao.js e LivroDao, respectivamente?
A classe LivroDao será responsável por fazer o acesso ao banco de dados em referência aos livros no sistema. Isso é uma implementação de um padrão
de projeto muito famoso, chamado DAO - Data Access Object(objeto de acesso aos dados)
No mundo da programação, é muito comum nomearmos esses elementos com a palavra DAO precedida pelo tipo de dados que estamos acessando, deixando bem 
claro que esse códigos são referentes à aplicação do padrão DAO.


** Cadastro Livros **

Vamos começar a desenvolver a funcionalidade de cadastro de livros da nossa aplicação. De volta ao código, criaremos, na pasta "livros", uma pasta "form"
contendo um arquivo form.marko, no qual construiremos o formulário de cadastro. Isso será feito com um HTML comum:

    <html>
        <body>
            <h1>Cadastro de livros</h1>

            <form action="/livros" method="post">

                <input type="hidden" id="id" name="id" />

                <div>
                    <label for="titulo">Titulo:</label>
                    <input type="text" id="titulo" name="titulo" placeholder="coloque o titulo" />
                </div>
                <div>
                    <label for="preco">Preço:</label>
                    <input type="text" id="preco" name="preco" placeholder="150.25" />
                </div>
                <div>
                    <label for="descricao">Descrição:</label>
                    <textarea cols="20" rows="10"  id="descricao" name="descricao" placeholder="fale sobre o livro"></textarea>
                </div>

                <input type="submit" value="Salvar" />
            </form>
        </body>
    </html>

Como podemos analisar, temos um cabeçalho informando que essa é a página de cadastro; um formulário definido pela tag <form>, contendo um input
oculto(para a id do nosso livro), campos de texto para o título e para o preço, e um textarea para a descrição do livro, um botão para submeter as informações do 
formulário; e a action indicando a URL para qual esses dados serão enviados, que nesse caso é /livros.
Também temos a definição do método de envio dos nossos dados que é POST, de modo eles sejam encapsulados no corpo da requisição e não apareçam na URL.
Agora precisaremos criar duas novas rotas na nossa aplicação. A primeira delas deve possibilitar ao usuário o acesso a esse formulário que acabamos de criar.
Em rotas.js, definiremos a URL /livros/form e uma função de callback que receberá req, resp e será executada sempre que o usuário fizer a requisição para essa rota.
Em seguida devolveremos o template do nosso formulário com resp.marko(require('../views/livros/form/form.marko))

    app.get('/livros/form', function(req, resp) {
        resp.marko(require('../views/livros/form/form.marko'))
    });

A nossa segunda rota será acessada sempre que o usuário fizer o envio dos dados do formulário. Essa rota, na verdade, já foi definida
no nosso formulário:
    <form action="/livros" method="post">

Mas como construiremos uma rota para o método POST do HTTP? É sem simples: utilizaremos a mesma sintaxe que em app.get(), substituindo-o 
pelo método post(), mantendo a função callback que será chamada. No corpo da função, como queremos apenas imprimir os dados que vieram do formulário, faremos
console.log(req.body)

    app.post('/livros', function(req, resp) {
        console.log(req.body);
    });

Após salvarmos as alterações no nosso projeto, poderemos testá-lo no navegador. Para isso, executaremos a aplicação e acessaremos a URL http://localhost:3000/livros/form.
O formulário simples que criamos em form.marko será exibido na tela
Se preenchermos os campos e clicarmos no botão "salvar", o navegador carregará a página por tempo indeterminado. Por que isso acontece?
No arquivo rotas.js, quando criamos o método post(), definimos apenas que o Node faria a exibição, no console, das informações do corpo da requisição. 
Ou seja, ainda precisamos definir uma visualização a ser exibida para o usuário, e faremos isso em aulas posteriores.
Por enquanto, precisamos saber se os dados no corpo da requisição realmente foram recebidos. Abrindo o Prompt de Comando, encontraremos... "undefined"?
Isso significa que o Node não conseguiu trazer os dados do formulário para o corpo da requisição. Pode ser uma surpresa, mas esse é o comportamento padrão e esperado do Node!

** Middlewares **

Atualmente, quando preenchemos o formulário de cadastro de livros em http://localhost:3000/livros/form e clicamos em salvar, recebemos no console um 
"undefined" ao invés dos dados que esperávamos.
Nosso objetivo agora é pegarmos as informações da requisição recebida do navegador antes de enviá-las à rota onde a lógica da nossa aplicação é implementada.
No Node, isso é possível por meio dos famosos MIDDLEWARES, que funcionam como filtros. Com eles, podemos, por exemplo, manipular uma requisição
antes que ela chegue na nossa lógica de négocios.
Dessa forma, conseguimos desenvolver diversos tipos de funcionalidades, como fazer auditoria nas requisições ou aplicar segurança em uma aplicação,
verificando se o usuário tem ou não autorização para acessar determinada lógica.
Para começarmos a implementar mais essa funcionalidade, precisaremos, primeiramente, instalar o body-parser, o módulo do Node que nos ajudará nessa tarefa:
    npm install body-parser@1.18.3 --save-exact

Feito isso, no custom-express.js, criaremos uma nova constante bodyParser que vai receber o retorno do require('body-parser'). Em seguida,
usaremos o app (que é o objeto do express) para invocar o método use() recebendo exatamente o middleware que queremos definir na nossa aplicação.
Passaremos bodyParser, para qual delegaremos a criação desse middleware, e o método urlencoded(), que define como o body-parser deve funcionar, e que 
está ligado à forma padrão de envio dos formulários HTML.
Esse método receberá um objeto JavaScript com a configuração extended: true. Dessa forma, ele estará habilitado a receber objetos complexos em formato .json
vindos do nosso formulário no navegador. Fazendo essa configuração, o bodyParser nos devolverá o middleware que precisamos.
Agora basta salvarmos nossas alterações e executarmos novamente nossa aplicação. Na página http://localhost:3000/livros/form, preencheremos os
campos aleatoriamente e clicaremos em Salvar. A página continuará carregando por tempo indeterminado, mas o importante nesse momento é a mensagem no console:

    {id: "", título: "", preco: "", descricao: ""}

Teremos um id vazio,pois ainda não definimos nenhum; e o resto dos campos preenchidos exatamente como definimos no formulário. Sendo assim, já estamos
aptos a fazer o cadastro de livros em nosso banco de dados!

De volta ao rotas.js, vamos copiar o código de listagem de livros, pois é sobre ele que construiremos o acesso ao banco, colocaremos esse código na em que fazemos
o método post() para /livros:

    app.post('/livros', function(req, resp) {
        console.log(req.body);
        const livroDao = new LivroDao(db);
        livroDao.lista()
                .then(livros => resp.marko(
                    require('../views/livros/lista/lista.marko'),
                    {
                        livros: livros
                    }

                ))
                .catch(erro => console.log(erro));
    });

Vamos relembrar? Estamos criando uma instância de livroDao e passando a instância do banco de dados(db) que foi definida no início do arquivo rotas.js.
Em seguida, utilizamos a instância do livroDao para chamar o método lista(). Dessa vez, queremos chamar um método adiciona(), que receberá req.body,
em que estão armazenados os dados dos nossoslivros.
A exemplo do lista(), esse método nos devolverá uma Promisse, nos permitindo executar o método then() (que ainda não sabemos como se comportará). No catch(),
continuaremos fazendo um consolo.log() do erro:

    app.post('/livros', function(req, resp) {
        console.log(req.body);
        const livroDao = new LivroDao(db);
        livroDao.adiciona(req.body)
                .then()   
                .catch(erro => console.log(erro));
    });

Ainda precisamos:
    .decidir o que fazer quando conseguirmos adicionar os livros no banco de dados,
    .criar o método adiciona() no nosso livro-dao.js


    Para saber mais:

    Para se aprofundar um pouco mais nas possibilidades que os middlewares nos oferecem, João pesquisou um pouco sobre o assunto e descobriu 
    que o método use() do Express pode receber dois parâmetros, sendo o primeiro uma string que define as URLs que serão atendidas pelo middleware 
    e como segundo parâmetro uma função. É essa função que irá definir o que o middleware deverá fazer e, por sua vez, recebe três parâmetros,
    a requisição, a resposta e uma função (normalmente chamada de next) que deve ser invocada para que o Express avance para o próximo middleware
    existente e caso não exista mais nenhum, passa a execução para a rota ativada. Sendo assim, a ordem em que os middlewares são definidos é
    de extrema importância! Além disso, um detalhe a ser observado, é que tudo que estiver antes da chamada da função next será executado 
    antes da rota ativada e o que estiver após a chamada da função next será executado somente ao término da rota ativada!
    ** Para saber mais: http://expressjs.com/pt-br/guide/using-middleware.html **

*** Persistência e redirecionamento ***

Precisamos adicionar o método adiciona() no nosso livro-dao.js, recebendo req.body(que representa o livro) e devolvendo uma Promisse que será tratada
na nossa rota /livros.

    adiciona(livro) {
        return new Promisse((resolve, reject) => {

        })
    }

Agora temos que implementar o corpo dessa Promisse, dizendo para a aplicação como ela deve fazer para pegar o livro que o método está recebendo e efetivamente
inserindo-o no banco de dados.
Com this, pegaremos a instância do nosso banco(_db) e executaremos o run(), um método SQlite utilizado para executar, no banco de dados, instruções que não retornem nenhum resultado,
como as instruções de inserção, deleção e atualização.
Esse método(run()) receberá três parâmetros. O primeiro dele é a string representando a instrução que queremos executar no banco de dados - nesse caso,
a instrução de inserção:

    adiciona(livro) {
            return new Promise((resolve, reject) => {
                this._db.run(`
                INSERT INTO LIVROS (
                        titulo,
                        preco,
                        descricao
                    ) values (?, ?, ?)
                `,)

            });
        } 

Aquim estamos inserindo nos campos titulo, preco e descricao, com os valores ?, ?, ?. Cada uma dessas interrogações representa uma informação do nosso livro,
ou seja, título, preço e descrição, respectivamente. Se tivéssemos mais informações, bastaria adicionarmos mais interrogações.
Como segundo parâmetro, passaremos um array com as informações que substituirão essas interrogações:

    adiciona(livro) {
        return new Promise((resolve, reject) => {
            this._db.run(`
            INSERT INTO LIVROS (
                    titulo,
                    preco,
                    descricao
                ) values (?, ?, ?)
            `,
            [
                livro.titulo,
                livro.preco,
                livro.descricao
            ], 
        )        
        });
    } 

Repare que, no array é necessário manter exatamente a mesma ordem que foi colocada na instrução de inserção, de modo que as informações sejam inseridas nas colunas correspondentes.
O último parâmetro que passaremos é uma função callback que será executada ao final dessa inserção. Essa função receberá, como parâmetro, somente um erro(err)-lembrando
que o método run() não retorna nenhum resultado, somente um erro (caso ocorra um).
Em caso de erro, ele será somente impresso no console, além de executarmos a função reject() dizendo "Não foi possível adicionar o livro". Caso contrário,
simplemente resolveremos a Promise.

    adiciona(livro) {
        return new Promise((resolve, reject) => {
            this._db.run(`
                INSERT INTO LIVROS (
                        titulo,
                        preco,
                        descricao
                    ) values (?, ?, ?)
                `,
                [
                    livro.titulo,
                    livro.preco,
                    livro.descricao
                ],
                function (err) {
                    if (err) {
                        console.log(err);
                        return reject('Não foi possível adicionar o livro!');
                    }

                    resolve();
                } 
            )       
        });
    } 

Feito isso, no rotas.js, podemos definir o que será feito quando o livro for adicionado ao banco de dados. Ao final da inserção, queremos retornar para a página 
de listagem de livros. Como já definimos essa página anteriormente, iremos simplemente redirecionar o usuário para uma rota já existente.

    app.post('/livros', function(req, resp) {
        console.log(req.body);
        const livroDao = new LivroDao(db);
        livroDao.adiciona(req.body)
                .then()   
                .catch(erro => console.log(erro));
    });

Para isso, no método then(), utilizaremos a resposta(resp) para invocar o método redirect(), que recebe como parâmetro uma string identificando a rota
que queremos acionar- nesse caso, /livros

    app.post('/livros', function(req, resp) {
        console.log(req.body);
        const livroDao = new LivroDao(db);
        livroDao.adiciona(req.body)
                .then(resp.redirect('/livros'))
                .catch(erro => console.log(erro));
    });

Feito isso, poderemos acessar a URL http://localhost:3000/livros/form para testarmos essa nova funcionalidade. Adicionando quaisquer valores
para os campos "Título", "Preço" e "Descrição", e em seguida clicando em "Salvar", seremos redirecionados para a página http://localhost:3000/livros. 
Nela, o novo livro terá sido cadastrado.

*** Remoção de Livros ***

Daremos continuidade ao desenvolvimento da aplicação, implementando a funcionalidade de remoção de livros da listagem. De volta ao código, alteraremos mais
três colunas no HTML da listagem de livros: o "Preço", um link para "Editar" e um link para "Remover"

    <html>
        <head>
            <meta charset="utf-8">
        </head>
        <body>
            <h1> Listagem de livros </h1>

            <table id="livros">
                <tr>
                    <td>ID</td>
                    <td>Título</td>
                    <td>Preço</td>
                    <td>Editar</td>
                    <td>Remover</td>
                </tr>
                <tr id="livro_${livro.id}" for (livro in data.livros)> 
                    <td>${livro.id}</td>
                    <td>${livro.titulo}</td>
                    <td>${livro.preco}</td>
                    <td><a href="#">Editar</a></td> 
                    <td><a href="#" data-ref="${livro.id}" data-type="remocao">Remover</a></td> 
                </tr>
            </table> 

            <script src="./remove-livro.js">
            </script> 
        </body> 
    </html>

Em cada uma das <tr>, colocamos uma id com a informação livro_ seguida do respectivo id desse livro. Além disso, no link de remoção, utilizamos a
dataset API do HTML para informar que esse link faz referência a um determinado livro, passando o id dele.
Perceba que a propriedade href do link de remoção recebeu apenas um #, e não uma URL indicando para onde será feita a requisição. Isso porque é o JavaScript
que terá a responsabilidade de enviar a requisição para nosso servidor, que efetivamente removerá o livro do banco de dados e devolverá uma resposta 
dizendo se a remoção ocorreu com sucesso ou não.
Dep posse dessa resposta, o JavaScript atualizará (ou não) a listagem, evitando que seja necessário recarregar toda a listagem novamente. Justamente por isso,
temos declarado um arquivo de JavaScript chamado remove-livros.js (localizado na mesma pasta do arquivo de listagem), responsável por enviar a requisição
para o servidor e remover o livro.
Nesse arquivo, selecionaremos a tabelaLivros e adicionaremos nela um ouvinte para o evento de clique. Se o elemento que foi clicado tiver o data type remocao, 
saberemos que é o nosso link de remoção. Em seguida, pegaremos o dataref com o Id do nosso livro, e com a fetch() do JavaScript, faremos uma requisição para a URL
/livros/${livroId} (que será um valor númerico).
Além disso, nossa requisição terá que ser feita com o método DELETE do HTTP. Se tivermos uma resposta positiva do servidor, removeremos a linha da tabela
referente a aquele ID. Se houver um problema, será feito um console.log() do erro.

    let tabelaLivros = document.querySelector('#livros');
    tabelaLivros.addEventListener('click', (evento) => {
        let elementoClicado = evento.target;

        if (elementoClicado.dataset.type == 'remocao') {
            let livroId = elementoClicado.dataset.ref;
            fetch(`http://localhost:3000/livros/${livroId}`, { method: 'DELETE' })
                .then(resposta => {

                    let tr = elementoClicado.closest(`#livro_${livroId}`);
                    tr.remove();

                })
                .catch(erro => console.log(erro));

        }

    });

Todo esse processo se dará do lado do navegador. Como serão feitas requisições para http://localhost:3000/livros/${livroId}, precisaremos criar
uma rota que consiga atender à essa requisição para o método DELETE. No arquivo rotas.js, escreveremos o método app.delete(), seguido da URI que queremos acessar e 
da função callback que recebe req e resp.
Precisamos que o express saiba que a informação que estamos passando na URL é a id do livro que queremos excluir, e que essa informação é variável
para cada requisição. Felizmente, o express nos possibilita criar variáveis na própria URL da rota. Para isso, basta usarmos dois pontos(:) seguidos
do nome da variável, que nesse caso é id.
Para recuperarmos esse valor, basta, dentro do callback, buscarmos o id entre os parâmetros dentro da requisição (req.params.id). Essa informação será salva
em uma constante id.

    app.delete('/livros/:id', function(req, resp) {
        const id = req.params.id;
    })

Poderemos, então criar uma nova constante livroDao, responsável por fazer o acesso ao banco de dados. Em seguida, chamaremos o método de remoção do nosso
livroDao, recebendo o id:

    app.delete('/livros/:id', function(req, resp) {
        const id = req.params.id;

        const livroDao = new LivroDao(db);
        livroDao.remove(id)
    });

Dessa vez, se tudo der certo, não queremos mostrar uma nova página ao usuário, mas apenas informá-lo que a requisição de remoção funcionou, 
ou seja, devolver um status HTTP de valor 200.
Faremos isso com o método resp.status(200), finalizando essa reposta com o já conhecido end(). Caso algo dê errado, usaremos o catch(erro => console.log(erro)).
Assim teremos:

    app.delete('/livros/:id', function(req, resp) {
        const id = req.params.id;

        const livroDao = new LivroDao(db);
        livroDao.remove(id)
            .then(() => resp.status(200).end())
            .catch(erro => console.log(erro));

    });

Feito isso, salvaremos as alterações e iniciaremos novamente a aplicação. Acessando a URL http://localhost:3000/livros, clicaremos no botão 
"Remover" ao lado de qualquer um dos livros na lista. Porém, a única resposta que teremos será a mudança para a URL http://localhost:3000/livros#.
No console do navegador ("F12"), receberemos alguns erros:

Failed to load resource: the server responded with a status of 404 (Not Found)

Refused to execute script from 'http://localhost:3000/remove-livro.js' 
because its MIME type ('text/html') is not executable, and strict MIME type checking is enabled

*** Arquivos Estáticos ***

Ainda temos um problema pendente na nossa aplicação: não conseguimos remover o livro da nossa listagem da maneira que esperávamos.

    Failed to load resource: the server responded with a status of 404 (Not Found)

    Refused to execute script from 'http://localhost:3000/remove-livro.js' 
    because its MIME type ('text/html') is not executable, and strict MIME type checking is enabled

O próprio navagador nos informa que, na requisição, o recurso remove-livros.js não foi encontrado. Lembre-se de que para toda página que queremos retornar
para o navegador, estamos criando uma rota na aplicação. Porém, em nenhum momento criamos uma rota para esse arquivo estático JavaScript.
Desse modo, precisamos que nossa aplicação verifique se as requisições que ela recebe são referentes a um arquivo estático. Em caso positivo, ela precisa
tratá-las de maneira conseguir servir esses arquivos para o navagador(ou qualquer outro cliente que esteja acessando-a).

De volta ao nosso código, criaremos, dentro da pasta "app", uma pasta "public" na qual ficarão os arquivos estáticos da nossa aplicação.
Dentro dela, criaremos outra pasta, chamada "js", em que serão alocados especificamente os arquivos JavaScript. Também poderíamos 
ter uma pasta "img" para imagens, "CSS" para estilos, e assim por diante.
Moveremos o arquivo remove-livros.js paraa recém criada pasta "js". Precisaremos, então, filtrar as requisições que chegam 
à nossa aplicação. Já conhecemos um ótimo recurso para isso: os middlewares da plataforma Node.
No arquivo custom-express.js, após a declaração do bodyParser, começaremos declarando o método app.use(). Para ele, passaremos, como primeiro parâmetro,
uma URL que será usada para ativar o nosso middleware. Queremos que o express faça essa ativação sempre que encontrar a url /estatico, um identificador que indicará
para nossa aplicação que está sendo requerido um recurso estático.
Como segundo parâmetro, passaremos a configuração do middleware a ser executado. A boa notícia é que o próprio objeto do express possui uma configuração 
própria para arquivos estáticos, e somente é necessário chamá-lo com express.static().
Em seguida, indicaremos o diretório dos arquivos estáticos da nossa aplicação, passando uma string "src/app/public".
No arquivo lista.marko, alteraremos a tag <script> para que reflita a localização do remove-livros.js:
    <script src="/estatico/js/remove-livros.js></script>

Salvando essas alterações, reiniciaremos a aplicação e acessaremos a URL http://localhost:3000/livros. Nela, finalmente poderemos 
remover os livros da lista com sucesso!

*** Edição de Livros ***

Vamos implementar a funcionalidade de edição de livros. De volta ao arquivo rotas.js, criaremos uma nova rota para atender à URL /livros/form/:id, ou seja,
a URL do nosso formulário de cadastro, com a adição de uma sintaxe para a criação de varíaveis.
Essa rota receberá uma função callback que será executar sempre que o usuário requisitá-la. Com o id passado na URL, criaremos uma instância de livroDao, 
buscaremos o livro e, se der tudo certo, devolveremos a página de formulário da nossa aplicação, passando como parâmetro um objeto JavaScript com 
a propriedade livro e recebendo o valor livro que acabamos de receber.
Se houver algum erro, vamo exibi-lo no console:

    app.get('/livros/form/:id', function(req, resp) {
        const id = req.params.id;
        const livroDao = new LivroDao(db);

        livroDao.buscaPorId(id)
            .then(livro => 
                resp.marko(
                    require('../views/livros/form/form.marko'),
                    { livro: livro }
                )
            )
            .catch(erro => console.log(erro));

    });

No <input type "hidden"/> do arquivo form.marko, atribuiremos o valor do id do livro que foi passado para nosso template (${data.livro.id}). Faremos
a mesma coisa para o título (${data.livro.titulo}), para o preço(${data.livro.preco}) e descrição(${data.livro.descricao}):

    <html>
        <body>
            <h1>Cadastro de livros</h1>

            <form action="/livros" method="post">

                <input type="hidden" id="id" name="id" value="${data.livro.id}" />

                <div>
                    <label for="titulo">Titulo:</label>
                    <input type="text" id="titulo" name="titulo" value="${data.livro.titulo}" placeholder="coloque o titulo" />
                </div>
                <div>
                    <label for="preco">Preço:</label>
                    <input type="text" id="preco" name="preco" value="${data.livro.preco}" placeholder="150.25" />
                </div>
                <div>
                    <label for="descricao">Descrição:</label>
                    <textarea cols="20" rows="10"  id="descricao" name="descricao"  placeholder="fale sobre o livro">${data.livro.descricao}</textarea>
                </div>

                <input type="submit" value="Salvar" />
            </form>
        </body>
    </html>

Já no link de edição do arquivo lista.marko, preencheremos o atributo href, que antes estava apenas com #, com /livros/form/${livro.id}, que é 
exatamente a rota que acabamos de criar. Com essas alterações salvasm podemos testar a nova funcionalidade do navegador.
Acessando http://localhost:3000/livros/, clicaremos em qualquer um dos links "Editar" ao lado dos elementso da lista. Se clicaramos no 
primeiro, por exemplo, seremos redirecionados para  http://localhost:3000/livros/form/1, a página do nosso formulário já preenchida com as 
informações do livro.
Porém, se tentarmos entrar na página http://localhost:3000/livros/form, nada será exibido. No console, teremos uma mensagem informando que os cabeçalhos
não foram enviados com sucesso para o cliente.
Isso acontece porque, na página form.marko, estamos esperando um atributo chamado livro. Porém, isso só acontece quando estamos editando um livro em 
/livros/form/:id, passando o livro retornado da nossa busca para o template.
No entanto a rota /livros/form, nenhum dado livro é passado, quebrando a aplicação. Para resolvermos esse problema, nessa rotam passaremos o método 
resp.marko() um objeto JavaScript com a propriedade livro vazia:

    app.get('/livros/form', function(req, resp) {
        resp.marko(require('../views/livros/form/form.marko'), { livro: {} });
    });
Após salvarmos nosso projeto, a URL http://localhost:3000/livros/form voltará a funcionar normalmente. Voltando para nossa listagem, se tentarmos editar
um dos livros na nossa lista e clicarmos em "Salvar", teremos um problema: ao invés das informações serem atualizadas, um novo livro será adicionado à listagem.
Isso acontece pois, no nosso formulário, estamos submetendo as informações com o método POST. Porém, no nosso arquivo rotas.js, a rota /livros foi criada para
adicionar um novo livro na tabela. Consequentemente, o método de adição que é executado.

